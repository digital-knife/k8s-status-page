replicaCount: 1

image:
  repository: python
  tag: "3.11-slim"
  pullPolicy: IfNotPresent

app:
  port: 5000
  healthCheckPath: /health
  command: ["python3"]
  args:
    - "-c"
    - |
      import http.server
      import socketserver
      import json
      import urllib.request
      import time
      from collections import defaultdict
      PORT = 5000
      HEALTH_PATH = '/health'
      TARGETS = [
        {'name': 'jenkins', 'url': 'http://jenkins.jenkins.svc.cluster.local:8080'},
        {'name': 'website', 'url': 'http://http-echo:5678'}
      ]
      scrape_counter = defaultdict(int)
      scrape_time = defaultdict(float)
      class HealthHandler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
          if self.path == HEALTH_PATH:
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({'status': 'ok'}).encode())
          elif self.path == '/':
            status_data = {}
            for target in TARGETS:
              start = time.time()
              try:
                req = urllib.request.Request(target['url'])
                with urllib.request.urlopen(req, timeout=5) as response:
                  elapsed = time.time() - start
                  scrape_counter[target['name']] += 1
                  scrape_time[target['name']] = elapsed
                  status_data[target['name']] = {
                    'url': target['url'],
                    'status': response.status,
                    'expected': 200,
                    'ok': response.status == 200
                  }
              except Exception as e:
                elapsed = time.time() - start
                scrape_time[target['name']] = elapsed
                status_data[target['name']] = {
                  'url': target['url'],
                  'status': str(e),
                  'expected': 200,
                  'ok': False
                }
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(status_data).encode())
          elif self.path == '/metrics':
            self.send_response(200)
            self.send_header('Content-type', 'text/plain; version=0.0.4')
            self.end_headers()
            self.wfile.write(b'# HELP status_scrape_count Number of scrapes for each target\\n')
            self.wfile.write(b'# TYPE status_scrape_count counter\\n')
            for name, count in scrape_counter.items():
              self.wfile.write(f'status_scrape_count{{target="{name}"}} {count}\\n'.encode())
            self.wfile.write(b'# HELP status_scrape_duration_seconds Duration of last scrape\\n')
            self.wfile.write(b'# TYPE status_scrape_duration_seconds gauge\\n')
            for name, duration in scrape_time.items():
              self.wfile.write(f'status_scrape_duration_seconds{{target="{name}"}} {duration}\\n'.encode())
            self.wfile.write(b'prometheus_scrape_success 1\\n')
          else:
            self.send_response(404)
            self.end_headers()
      httpd = socketserver.TCPServer(("", PORT), HealthHandler)
      print(f'Status Server on port {PORT}')
      httpd.serve_forever()
  targets:
    - name: jenkins
      url: http://jenkins.jenkins.svc.cluster.local:8080/metrics
      expectedStatus: 200
    - name: website
      url: http://http-echo:5678
      expectedStatus: 200

serviceAccount:
  create: false

service:
  type: NodePort
  port: 80
  nodePort: 30080

resources:
  limits:
    cpu: "200m"
    memory: "256Mi"
  requests:
    cpu: "100m"
    memory: "128Mi"

livenessProbe:
  httpGet:
    path: /health
    port: 5000
  initialDelaySeconds: 10
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /health
    port: 5000
  initialDelaySeconds: 5
  periodSeconds: 5
# Test webhook file change
# Test webhook code change
